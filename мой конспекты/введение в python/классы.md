#Классы_Python #Объектно_ориентированное_программирование_ОПП #Наследование_классов #Полиморфизм_в_Python
Классы в Python - это шаблоны или модели, которые определяют структуру объектов. Они позволяют создавать объекты с определенным набором атрибутов и методов. Классы - это основа объектно-ориентированного программирования (ООП) в Python.

### **Введение в ООП и классы в Python**
Объектно-ориентированное программирование (ООП) - это парадигма программирования, которая использует "объекты" и их взаимодействия для разработки программного обеспечения. В Python, как и в других ООП-языках, основными концепциями являются классы и объекты. Класс - это шаблон, по которому создаются объекты. Объект - это экземпляр класса, содержащий данные и методы для работы с этими данными.

### **Создание класса: синтаксис и примеры**
Создание класса в Python начинается с ключевого слова `class`, за которым следует имя класса и двоеточие. Внутри класса определяются атрибуты (переменные) и методы (функции). Атрибуты класса могут быть как общими для всех объектов класса, так и уникальными для каждого объекта. Методы класса - это функции, которые определены внутри класса и могут работать с его атрибутами.
```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def bark(self):
        return f"{self.name} says woof!"
```
### **Статические и динамические атрибуты**

Вот вы говорите конструктор, инициализатор… А что, если я объявлю и инициализирую атрибут вне метода `__init__`?
```python
class Bird:
    ruClassName = "Птица"

    def __init__(self, name):
        self.name = name
```
И такое тоже практикуют. И такие атрибуты даже имеют свое название и применение:
```python
b = Bird("Я объект b, класса " + Bird.ruClassName)
print(b.name)
```
Атрибут `ruClassName` называется статическим. А атрибут `name` - динамическим. Заметьте, что внутри класса к статическим атрибутам мы не обращаемся через `self`. Вне класса мы обращаемся к статическим атрибутам не через **<имя объекта> с точкой**, а через **<Имя класса> с точкой.** _То же самое, кстати, требуется делать со статическим атрибутом и внутри методов класса!_ Иначе работать не будет.

### **Наследование и полиморфизм**
Наследование позволяет создавать новый класс на основе существующего. Новый класс (подкласс) наследует атрибуты и методы родительского класса (суперкласса), но также может добавлять свои собственные. Это позволяет повторно использовать код и расширять функциональность классов.
```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        raise NotImplementedError("Subclass must implement abstract method")

class Dog(Animal):
    def speak(self):
        return f"{self.name} says woof!"

class Cat(Animal):
    def speak(self):
        return f"{self.name} says meow!"
```
Полиморфизм позволяет использовать один и тот же интерфейс для разных типов объектов. Это достигается за счет наследования и переопределения методов.
### **Пример полиморфизма**
```python
animals = [Dog("Buddy"), Cat("Whiskers")]

for animal in animals:
    print(animal.speak())
```
Вывод:
```python
Buddy says woof!
Whiskers says meow!
```