import pygame

import random

  

# Определяем размеры окна и сетки

WIDTH, HEIGHT = 300, 600

BLOCK_SIZE = 30

GRID_WIDTH = WIDTH // BLOCK_SIZE

GRID_HEIGHT = HEIGHT // BLOCK_SIZE

  

# Цвета

BLACK = (0, 0, 0)

WHITE = (152, 251, 152)

COLORS = [

    (0, 255, 255),  # Циан

    (255, 165, 0),  # Оранжевый

    (0, 0, 255),    # Синий

    (255, 0, 0),    # Красный

    (128, 0, 128),  # Пурпурный

    (0, 255, 0),    # Зеленый

    (255, 255, 0)   # Желтый

]

  

# Определяем фигуры Тетриса

SHAPES = [

    [[1, 1, 1, 1]],  # Линия

    [[1, 1], [1, 1]],  # Квадрат

    [[0, 1, 0], [1, 1, 1]],  # Т-образная

    [[1, 1, 0], [0, 1, 1]],  # Z-образная

    [[0, 1, 1], [1, 1, 0]],  # S-образная

    [[1, 0, 0], [1, 1, 1]],  # L-образная

    [[0, 0, 1], [1, 1, 1]]   # J-образная

]

  

class Piece:

    def __init__(self, shape):

        self.shape = shape

        self.color = random.choice(COLORS)

        self.x = GRID_WIDTH // 2 - len(shape[0]) // 2

        self.y = 0

  

    def rotate(self):

        self.shape = [list(row) for row in zip(*self.shape[::-1])]

  

class Tetris:

    def __init__(self):

        self.grid = [[0] * GRID_WIDTH for _ in range(GRID_HEIGHT)]

        self.current_piece = self.new_piece()

        self.score = 0

  

    def new_piece(self):

        return Piece(random.choice(SHAPES))

  

    def valid_move(self, dx, dy):

        for y, row in enumerate(self.current_piece.shape):

            for x, block in enumerate(row):

                if block:

                    new_x = self.current_piece.x + x + dx

                    new_y = self.current_piece.y + y + dy

                    if new_x < 0 or new_x >= GRID_WIDTH or new_y >= GRID_HEIGHT:

                        return False

                    if new_y >= 0 and self.grid[new_y][new_x]:

                        return False

        return True

  

    def merge_piece(self):

        for y, row in enumerate(self.current_piece.shape):

            for x, block in enumerate(row):

                if block:

                    self.grid[self.current_piece.y + y][self.current_piece.x + x] = 1

        self.clear_lines()

  

    def clear_lines(self):

        lines_to_clear = [i for i, row in enumerate(self.grid) if all(row)]

        for i in lines_to_clear:

            del self.grid[i]

            self.grid.insert(0, [0] * GRID_WIDTH)

            self.score += 1

  

    def drop_piece(self):

        if self.valid_move(0, 1):

            self.current_piece.y += 1

        else:

            self.merge_piece()

            self.current_piece = self.new_piece()

            if not self.valid_move(0, 0):

                print("Game Over!")

                pygame.quit()

                exit()

  

    def draw(self, screen):

        screen.fill(BLACK)

        for y in range(GRID_HEIGHT):

            for x in range(GRID_WIDTH):

                if self.grid[y][x]:

                    pygame.draw.rect(screen, WHITE, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))

        for y, row in enumerate(self.current_piece.shape):

            for x, block in enumerate(row):

                if block:

                    pygame.draw.rect(screen, self.current_piece.color,

                                     ((self.current_piece.x + x) * BLOCK_SIZE, (self.current_piece.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))

        pygame.display.flip()

  

def main():

    pygame.init()

    screen = pygame.display.set_mode((WIDTH, HEIGHT))

    clock = pygame.time.Clock()

    game = Tetris()

  

    while True:

        for event in pygame.event.get():

            if event.type == pygame.QUIT:

                pygame.quit()

                exit()

            if event.type == pygame.KEYDOWN:

                if event.key == pygame.K_LEFT and game.valid_move(-1, 0):

                    game.current_piece.x -= 1

                elif event.key == pygame.K_RIGHT and game.valid_move(1, 0):

                    game.current_piece.x += 1

                elif event.key == pygame.K_DOWN:

                    game.drop_piece()

                elif event.key == pygame.K_UP:

                    game.current_piece.rotate()

                    if not game.valid_move(0, 0):

                        game.current_piece.rotate()  # Возврат, если поворот невалиден

  

        game.drop_piece()

        game.draw(screen)

        clock.tick(10)  # Устанавливаем скорость игры

  

if __name__ == "__main__":

    main()